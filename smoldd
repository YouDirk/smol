#!/usr/bin/env python3

import argparse
import glob
import os.path
import shutil
import subprocess
import struct
import sys

from smol.util import hash_djb2, readint, readstr, error
from smol.elf import ELFMachine


def get_def_libpaths(cc_bin, is32bit):
    if is32bit:
        return ['/usr/lib32/','/lib32/']

    out = subprocess.check_output([cc_bin, '-print-search-dirs'],
                                     stderr=subprocess.DEVNULL)

    stuff = {}
    for l in out.decode('utf-8').splitlines():
        cols = l.split(': ')
        stuff[cols[0]] = cols[1].lstrip('=').split(':')

    return stuff["libraries"]

def find_libs(bits, deflibs, libname):
    dirs = os.environ['LD_LIBRARY_PATH'].split(':') + deflibs

    for d in dirs:
        for f in glob.glob(glob.escape(d + libname) + '*'):
            yield f

def build_hashtab(scanelf_bin, lib):
    out = subprocess.check_output([scanelf_bin, '-B', '-F', '%s', '-s', '%pd%*', lib],
                                     stderr=subprocess.DEVNULL)

    lines = set(out.decode('utf-8').split('\n'))
    ret = {}

    for line in lines:
        cols = line.split()
        if len(cols) != 7:
            continue
        ret[hash_djb2(cols[6])] = cols[6]

    return ret

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('input', type=argparse.FileType('rb'),
                        default=sys.stdin.buffer, help="input file")
    parser.add_argument('--cc',
                        default=shutil.which('cc'), help="C compiler binary")
    parser.add_argument('--scanelf',
                        default=shutil.which('scanelf'), help="scanelf binary")

    args = parser.parse_args()

    blob = args.input.read()

    bits = blob[4] * 32
    machnum = struct.unpack('<H', blob[18:18+2])[0]
    try:
        machine = ELFMachine(machnum)
    except:
        error('unknown architecture: {}'.format(machnum))

    deflibs = get_def_libpaths(args.cc, bits == 32)

    phoff, phsz, phnum = 0, 0, 0
    if bits == 32:
        phoff = struct.unpack('<I', blob[28:28+4])[0]
        phsz  = struct.unpack('<H', blob[42:42+2])[0]
        phnum = struct.unpack('<H', blob[44:52+2])[0]
    elif bits == 64:
        phoff = struct.unpack('<Q', blob[32:32+8])[0]
        phsz  = struct.unpack('<H', blob[54:54+2])[0]
        phnum = struct.unpack('<H', blob[56:56+2])[0]

    for i in range(phnum):
        off = phoff + i * phsz

        ptyp, poff, pva, ppa, pfsz, pmsz, pfl, pal = 0,0,0,0,0,0,0,0
        if bits == 32:
            ptyp, poff, pva, ppa, pfsz, pmsz, pfl, pal = \
                struct.unpack('<ILLLIIII', blob[off:off+phsz])
        else:
            ptyp, pfl, poff, pva, ppa, pfsz, pmsz, pal = \
                struct.unpack('<IIQQQQQQ', blob[off:off+phsz])

        if ptyp != 2: # PT_DYNAMIC
            continue

        # right after the dynamic section, the smol 'symtab'/'hashtab' is found
        #
        # note that on i386, every lib name is followed by an E9 byte
        # if the next libname/first byte of the hash is null, the table has
        # come to an end.

        if bits == 32:
            j = poff
            strtaboff = 0
            while j < poff + pfsz:
                tag, j = readint(blob, j)
                ptr, j = readint(blob, j)

                if tag == 5: # DT_STRTAB
                    strtaboff = ptr
                elif tag == 1: # DT_NEEDED
                    bakoff = j

                    smoltaboff = strtaboff + ptr - (pva - poff)
                    j = smoltaboff

                    libname, j = readstr(blob, j)
                    if len(libname) == 0:
                        break

                    sys.stdout.write("* " + libname)

                    libs = list(find_libs(32, deflibs, libname))
                    print(" -> NOT FOUND" if len(libs) == 0 else (" -> " + libs[0]))
                    ht = dict({}) if len(libs) == 0 else build_hashtab(args.scanelf, libs[0])

                    while True:
                        hashv, j = readint(blob, j)

                        if (hashv & 0xFF) == 0:
                            break

                        sys.stdout.write("  * " + hex(hashv))
                        print(" -> NOT FOUND" if hashv not in ht else (" -> " + ht[hashv]))

                    j = bakoff

            break
        else: # 64-bit
            error('Currently unsupported, sorry.')

if __name__ == '__main__':
    main()

