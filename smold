#!/usr/bin/env python3

import argparse
import os
from   os import path
import shutil
import sys
import tempfile

from smol.util  import error, doexec
from smol.elf   import ELFMachine, ELF_DEFAULT_BITS
from smol.parse import decide_arch, find_lib, find_symbol, get_cc_paths, \
                       get_needed_syms, ld_is_cc
from smol.emit  import output_table


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-m', '--target',
        help='architecture to generate asm code for (default: auto)')
    parser.add_argument('-l', '--library', metavar='LIB', action='append',
        help='libraries to link against')
    parser.add_argument('-L', '--libdir', metavar='DIR', action='append',
        help='directories to search libraries in')


    parser.add_argument('--hash16', default=False, action='store_true', \
        help="Use 16-bit (BSD) hashes instead of 32-bit djb2 hashes. "\
            +"Must be used with -Duse_dnload_loader")
    parser.add_argument('--nx', default=False, action='store_true', \
        help="Use NX (i.e. don't use RWE pages). Costs the size of one phdr, "\
            +"plus some extra bytes on i386.")

    parser.add_argument('-D', '--smol-opt', metavar='OPT', default=['use_interp'], action='append',
        help='optimization flags for smol')
    parser.add_argument('--linker-dir', default=path.join(path.dirname(__file__), 'ld'),
        help='path to link-time files')
    parser.add_argument('--runtime-dir', default=path.join(path.dirname(__file__), 'rt'),
        help='path to runtime code files')
    parser.add_argument('--nasm', default=os.getenv('NASM') or shutil.which('nasm'),
        help='which nasm binary to use')
    parser.add_argument('--ld', default=os.getenv('LD') or shutil.which('ld'),
        help='which ld binary to use')
    parser.add_argument('--cc', default=os.getenv('CC') or shutil.which('cc'),
        help='which cc binary to use')
    parser.add_argument('--scanelf', default=os.getenv('SCANELF') or shutil.which('scanelf'),
        help='which scanelf binary to use')
    parser.add_argument('--readelf', default=os.getenv('READELF') or shutil.which('readelf'),
        help='which readelf binary to use')

    parser.add_argument('input', nargs='+', help='input object file(s)')
    parser.add_argument('-o', '--output', metavar='OUT', default='smol.out', help='output binary')

    args, ld_args = parser.parse_known_args()

    #print(args)

    for util in ['nasm', 'cc', 'scanelf', 'readelf', 'ld']:
        if not getattr(args, util):
            parser.error('utility "{u}" could not be found! either install" + \
                         " it or pass the path with --{u}'
                .format(u=util))

    opts = set()
    for opt in args.smol_opt[:]:
        if opt.startswith('-'):
            opts.discard(opt[1:])
            continue
        opts.add(opt)

    args.library = args.library or []
    args.libdir = args.libdir or []
    if args.target:
        arch = args.target.lower().replace('elf_', '')

        # compat with how gcc does things on x86es
        if arch == '32': arch = ELFMachine.i386
        elif arch == '64': arch = ELFMachine.x86_64
        else:
            if arch not in ELFMachine:
                parser.error('unknown architecture: {}'.format(arch))
            arch = ELFMachine(arch)

        bits = ELF_DEFAULT_BITS[arch]
    else:
        arch, bits = decide_arch(args.input)
        if not arch or not bits:
            error('Invalid architecture!')

    ldiscc = ld_is_cc(args.ld)

    if arch == ELFMachine.i386:
        ld_args.append("-m32" if ldiscc else "-melf_i386")
    elif arch == ELFMachine.i386:
        ld_args.append("-m32" if ldiscc else "-melf_x86_64")
    else: pass # shouldn't happen

    syms = get_needed_syms(args.readelf, args.input)
    paths = get_cc_paths(args.cc)

    libdirs = args.libdir + paths['libraries']
    libs = []
    libnames = args.library
    for libname in libnames:
        lib = find_lib(libdirs, libname)
        if not lib:
            error('could not find library: {}'.format(libname))
        libs.append(lib)

    symbols = {}
    for symbol, reloc in syms:
        library = find_symbol(args.scanelf, libs, libnames, symbol)
        if not library:
            error("could not find symbol: {}".format(symbol))
        symbols.setdefault(library, [])
        symbols[library].append((symbol, reloc))

    as_args = ['-D' + opt.upper() for opt in opts]
    with tempfile.NamedTemporaryFile('w', suffix='.asm') as table, \
            tempfile.NamedTemporaryFile('w', suffix='.o') as tableobj:
        output_table(arch, symbols, args.nx, args.hash16, table)
        table.flush()
        try:
            doexec([args.nasm] + as_args + \
                ['-I', args.runtime_dir + '/', '-f', 'elf{}'.format(bits), \
                    table.name, '-o', tableobj.name])
            oformat = ('-Wl,' if ldiscc else '') + '--oformat=binary'
            doexec([args.ld, '-T', \
                os.path.join(args.linker_dir, 'link.ld'), oformat, \
                                   '-o', args.output, tableobj.name] \
                                  + ld_args + args.input)
        except subprocess.CalledProcessError:
            sys.exit(1)


if __name__ == '__main__':
    main()
